<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BoostChatBot - AI Assistant for C++ Boost Library</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            color: white;
            font-size: 2rem;
            font-weight: 600;
            text-align: center;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
            margin-top: 0.5rem;
            font-size: 1.1rem;
        }

        .main-container {
            flex: 1;
            display: flex;
            height: calc(100vh - 200px);
            margin: 0 10px;
            width: 100%;
            padding: 1rem;
            padding-bottom: 120px;
            gap: 1rem;
        }

        .channels-sidebar {
            width: 250px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-container {
            width: 1200px;
            flex: 1;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 0;
        }

        .settings-panel {
            width: 250px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: transform 0.3s ease;
        }

        .settings-panel.hidden {
            transform: translateX(100%);
            width: 0;
            padding: 0;
            margin: 0;
        }

        .channels-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1.5rem;
            text-align: center;
        }

        .channels-header h2 {
            font-size: 1.2rem;
            margin-bottom: 1rem;
        }

        .new-chat-button {
            width: 100%;
            padding: 0.75rem 1rem;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            margin-bottom: 1rem;
        }

        .new-chat-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .example-questions-section {
            margin: 1rem;
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        .example-questions-header {
            background: #f8fafc;
            padding: 1rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e5e7eb;
            transition: background-color 0.2s ease;
        }

        .example-questions-header:hover {
            background: #e0e7ff;
        }

        .example-questions-header h3 {
            margin: 0;
            font-size: 1rem;
            font-weight: 600;
            color: #374151;
        }

        .expand-icon {
            font-size: 0.8rem;
            color: #6b7280;
            transition: transform 0.2s ease;
        }

        .example-questions-header.collapsed .expand-icon {
            transform: rotate(-90deg);
        }

        .example-questions-content {
            max-height: 500px;
            overflow-y: auto;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 1;
        }

        .example-questions-content.collapsed {
            max-height: 0;
            overflow: hidden;
            opacity: 0;
        }

        .channels-list {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
        }

        .channel-item {
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            background: #f8fafc;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .channel-item:hover {
            background: #e0e7ff;
            border-color: #667eea;
        }

        .channel-item.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .channel-name {
            font-weight: 500;
            margin-bottom: 0.25rem;
        }

        .channel-preview {
            font-size: 0.8rem;
            opacity: 0.7;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .channel-actions {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .channel-item:hover .channel-actions {
            opacity: 1;
        }

        .channel-delete {
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            font-size: 0.7rem;
            cursor: pointer;
        }

        .chat-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1.5rem;
            text-align: center;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-header h2 {
            font-size: 1.5rem;
            margin: 0;
        }

        .chat-header-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .settings-toggle {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .settings-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255, 255, 255, 0.2);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4ade80;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .chat-messages {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            scroll-behavior: smooth;
        }

        .message {
            display: flex;
            gap: 1rem;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            flex-direction: row-reverse;
        }

        .message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            flex-shrink: 0;
        }

        .message.user .message-avatar {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .message.bot .message-avatar {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
        }

        .message-content {
            background: #f8fafc;
            padding: 1rem 1.5rem;
            border-radius: 18px;
            max-width: 70%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .message.user .message-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .message-text {
            line-height: 1.6;
            margin-bottom: 0.5rem;
        }

        .message-meta {
            font-size: 0.8rem;
            opacity: 0.7;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .confidence-bar {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .confidence-fill {
            width: 60px;
            height: 4px;
            background: #e5e7eb;
            border-radius: 2px;
            overflow: hidden;
        }

        .confidence-progress {
            height: 100%;
            background: linear-gradient(90deg, #ef4444 0%, #f59e0b 50%, #22c55e 100%);
            transition: width 0.3s ease;
        }

        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem 1.5rem;
            background: #f8fafc;
            border-radius: 18px;
            max-width: 70%;
            border: 1px solid #e5e7eb;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            animation: slideIn 0.3s ease-out;
            margin-bottom: 1rem;
        }

        #typing-indicator {
            display: none;
        }

        .typing-dots {
            display: flex;
            gap: 4px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #9ca3af;
            animation: typing 1.4s infinite;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {

            0%,
            60%,
            100% {
                transform: translateY(0);
            }

            30% {
                transform: translateY(-10px);
            }
        }

        .chat-input-container {
            padding: 1.5rem;
            background: #f8fafc;
            border-top: 1px solid #e5e7eb;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            max-width: 1400px;
            margin: 0 auto;
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.1);
        }

        .chat-input-wrapper {
            display: flex;
            gap: 1rem;
            align-items: flex-end;
            position: relative;
        }

        .mode-selector {
            position: absolute;
            top: -3rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 0.5rem;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 0.25rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .mode-option {
            display: flex;
            align-items: center;
            cursor: pointer;
            padding: 0.5rem 1rem;
            border-radius: 15px;
            background: transparent;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            user-select: none;
        }

        .mode-option:hover {
            background: rgba(255, 255, 255, 0.8);
            transform: translateY(-1px);
        }

        .mode-option input[type="radio"] {
            display: none;
        }

        .mode-option:has(input[type="radio"]:checked) {
            background: rgba(102, 126, 234, 0.1);
            border-color: #667eea;
        }

        .mode-option input[type="radio"]:checked+.mode-label {
            color: #667eea;
            font-weight: 600;
        }

        .mode-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: #666;
            transition: all 0.3s ease;
        }

        .mode-icon {
            font-size: 1.1rem;
        }

        .search-results {
            margin: 1rem 0;
        }

        .search-results h3 {
            color: #667eea;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .search-result-item {
            background: rgba(102, 126, 234, 0.05);
            border: 1px solid rgba(102, 126, 234, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            transition: all 0.3s ease;
        }

        .search-result-item:hover {
            background: rgba(102, 126, 234, 0.1);
            transform: translateY(-1px);
        }

        .search-result-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .result-number {
            background: #667eea;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.8rem;
        }

        .result-method {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.8rem;
        }

        .result-score {
            color: #666;
            font-size: 0.8rem;
        }

        .search-result-file {
            color: #888;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .search-result-content {
            margin-top: 0.5rem;
        }

        .search-result-text {
            line-height: 1.6;
            color: #333;
        }

        .expand-search-btn {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            font-size: 0.9rem;
            margin-top: 0.5rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .expand-search-btn:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        .search-result-full {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: rgba(102, 126, 234, 0.05);
            border-radius: 4px;
            line-height: 1.6;
        }

        /* Retrieval Results Styles */
        .retrieval-results {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(34, 197, 94, 0.05);
            border: 1px solid rgba(34, 197, 94, 0.2);
            border-radius: 8px;
        }

        .retrieval-results h4 {
            color: #22c55e;
            margin: 0 0 1rem 0;
            font-size: 1rem;
            font-weight: 600;
        }

        .retrieval-result-item {
            background: rgba(34, 197, 94, 0.05);
            border: 1px solid rgba(34, 197, 94, 0.2);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            transition: all 0.3s ease;
        }

        .retrieval-result-item:hover {
            background: rgba(34, 197, 94, 0.1);
            transform: translateY(-1px);
        }

        .retrieval-result-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .retrieval-result-file {
            color: #888;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }

        .retrieval-result-content {
            margin-top: 0.5rem;
        }

        .retrieval-result-text {
            line-height: 1.6;
            color: #333;
        }

        .expand-retrieval-btn {
            background: none;
            border: none;
            color: #22c55e;
            cursor: pointer;
            font-size: 0.9rem;
            margin-top: 0.5rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .expand-retrieval-btn:hover {
            background: rgba(34, 197, 94, 0.1);
        }

        .retrieval-result-full {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: rgba(34, 197, 94, 0.05);
            border-radius: 4px;
            line-height: 1.6;
        }

        .chat-input {
            flex: 1;
            min-height: 50px;
            max-height: 120px;
            padding: 1rem;
            border: 2px solid #e5e7eb;
            border-radius: 25px;
            font-size: 1rem;
            resize: none;
            outline: none;
            transition: border-color 0.3s ease;
            font-family: inherit;
        }

        .chat-input:focus {
            border-color: #667eea;
        }

        .chat-input:disabled {
            background-color: #f3f4f6;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .send-button {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease;
        }

        .send-button:hover {
            transform: scale(1.05);
        }

        .send-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .send-button.loading {
            position: relative;
            color: transparent;
        }

        .send-button.loading::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            border: 2px solid #ffffff;
            border-top: 2px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .settings-panel-content {
            padding: 0.5rem;
            overflow-y: auto;
            flex: 1;
        }

        .settings-section {
            background: white;
            border-radius: 15px;
            padding: 1.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            margin-bottom: 1.5rem;
        }

        .settings-section h3 {
            color: #374151;
            margin-bottom: 1rem;
            font-size: 1.1rem;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
                padding: 1rem;
                height: calc(100vh - 180px);
                padding-bottom: 100px;
            }

            .channels-sidebar {
                width: 100%;
                height: 200px;
                order: -1;
            }

            .settings-panel {
                position: fixed;
                top: 0;
                right: 0;
                height: 100vh;
                z-index: 1000;
                transform: translateX(100%);
            }

            .settings-panel:not(.hidden) {
                transform: translateX(0);
            }

            .chat-input-container {
                padding: 1rem;
            }

            .message-content {
                max-width: 85%;
            }

            .header h1 {
                font-size: 1.5rem;
            }
        }

        .example-questions {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            padding: 1rem;
        }

        .example-question {
            padding: 0.75rem 1rem;
            background: #f8fafc;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.85rem;
            line-height: 1.4;
            position: relative;
        }

        .example-question:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .example-question:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.2);
        }

        .example-question::after {
            content: "‚Üí";
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0;
            transition: opacity 0.2s ease;
            font-weight: bold;
        }

        .example-question:hover::after {
            opacity: 1;
        }

        .settings-form {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .form-group label {
            font-size: 0.9rem;
            font-weight: 500;
            color: #374151;
        }

        .form-group select,
        .form-group input {
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 0.9rem;
            outline: none;
            transition: border-color 0.2s ease;
        }

        .form-group input[type="checkbox"] {
            margin-right: 0.5rem;
            width: auto;
            padding: 0;
        }

        .version-management {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .version-actions {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .form-group select:focus,
        .form-group input:focus {
            border-color: #667eea;
        }

        .retrieval-weights {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .weight-input {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .weight-input label {
            font-size: 0.85rem;
            color: #666;
            font-weight: 500;
        }

        .weight-input input {
            width: 100%;
            padding: 0.4rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .settings-button {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: transform 0.2s ease;
        }

        .settings-button:hover {
            transform: translateY(-2px);
        }

        .system-status {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid #f3f4f6;
        }

        .status-item:last-child {
            border-bottom: none;
        }

        .status-label {
            font-size: 0.9rem;
            color: #6b7280;
        }

        .status-value {
            font-size: 0.9rem;
            font-weight: 500;
            color: #374151;
        }

        .sources-section {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #e5e7eb;
        }

        .sources-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 0.75rem;
        }

        .source-item {
            background: #f8fafc;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            font-size: 0.8rem;
            line-height: 1.4;
        }

        .source-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .source-number {
            background: #667eea;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .source-method {
            background: #e0e7ff;
            color: #3730a3;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 500;
            text-transform: uppercase;
        }

        .source-score {
            color: #667eea;
            font-weight: 500;
            font-size: 0.7rem;
        }

        .source-file {
            color: #6b7280;
            font-size: 0.7rem;
            margin-bottom: 0.3rem;
            font-weight: 500;
        }

        .source-content {
            color: #374151;
            font-size: 0.75rem;
            line-height: 1.3;
        }

        .source-text-preview {
            margin-bottom: 0.5rem;
        }

        .expand-btn {
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            font-size: 0.7rem;
            color: #374151;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            transition: all 0.2s ease;
        }

        .expand-btn:hover {
            background: #e5e7eb;
            border-color: #9ca3af;
        }

        .expand-icon {
            transition: transform 0.2s ease;
        }

        .expand-btn.expanded .expand-icon {
            transform: rotate(180deg);
        }

        .source-text-full {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            font-size: 0.7rem;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .method-summary {
            background: #f1f5f9;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            padding: 0.5rem;
            margin-bottom: 0.75rem;
            font-size: 0.75rem;
            color: #475569;
        }

        .method-tag {
            background: #dbeafe;
            color: #1e40af;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-right: 0.3rem;
            display: inline-block;
        }

        .embedding-model {
            background: #f0f9ff;
            color: #0369a1;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            display: inline-block;
            border: 1px solid #bae6fd;
        }

        .reasoning-steps {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #e5e7eb;
        }

        .reasoning-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 0.75rem;
        }

        .reasoning-step {
            background: #f0f9ff;
            border-left: 3px solid #0ea5e9;
            padding: 0.5rem 0.75rem;
            margin-bottom: 0.5rem;
            font-size: 0.8rem;
            line-height: 1.4;
        }


        .error-message {
            background: #fef2f2;
            border: 1px solid #fecaca;
            color: #dc2626;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .success-message {
            background: #f0fdf4;
            border: 1px solid #bbf7d0;
            color: #16a34a;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        /* Structured content styles */
        .message-text h3 {
            color: #374151;
            font-size: 1.1rem;
            font-weight: 600;
            margin: 1rem 0 0.5rem 0;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 0.25rem;
        }

        .message-text h4 {
            color: #4b5563;
            font-size: 1rem;
            font-weight: 600;
            margin: 0.75rem 0 0.5rem 0;
        }

        .message-text p {
            margin: 0.5rem 0;
            line-height: 1.6;
        }

        .message-text ul,
        .message-text ol {
            margin: 0.5rem 0;
            padding-left: 1.5rem;
        }

        .message-text li {
            margin: 0.25rem 0;
            line-height: 1.5;
        }

        .message-text code {
            background: #f3f4f6;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            padding: 0.125rem 0.25rem;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #dc2626;
        }

        .message-text pre {
            background: #f8fafc;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 1rem;
            margin: 0.75rem 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.4;
        }

        .message-text pre code {
            background: none;
            border: none;
            padding: 0;
            color: #374151;
        }

        .message-text strong {
            font-weight: 600;
            color: #1f2937;
        }

        .message-text em {
            font-style: italic;
            color: #6b7280;
        }

        /* Edit message functionality styles */
        .user-message-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .message-actions {
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .message.user:hover .message-actions {
            opacity: 1;
        }

        .edit-message-btn {
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .edit-message-btn:hover {
            background: #e5e7eb;
            border-color: #9ca3af;
        }

        .edit-message-container {
            width: 100%;
            margin: 0.5rem 0;
        }

        .edit-message-input {
            width: 100%;
            min-height: 40px;
            max-height: 120px;
            padding: 0.75rem;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 0.9rem;
            font-family: inherit;
            resize: none;
            outline: none;
            background: #f8fafc;
        }

        .edit-message-input:focus {
            border-color: #4f46e5;
            background: white;
        }

        .edit-message-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
            justify-content: flex-end;
        }

        .save-edit-btn,
        .cancel-edit-btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .save-edit-btn {
            background: #10b981;
            color: white;
        }

        .save-edit-btn:hover {
            background: #059669;
        }

        .cancel-edit-btn {
            background: #6b7280;
            color: white;
        }

        .cancel-edit-btn:hover {
            background: #4b5563;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>üöÄ BoostChatBot</h1>
        <p>AI-powered assistant for C++ Boost library documentation</p>
    </div>

    <div class="main-container">
        <!-- Channels Sidebar -->
        <div class="channels-sidebar">
            <div class="channels-header">
                <h2>üí¨ Chat Channels</h2>
                <button id="new-chat-button" class="new-chat-button">
                    ‚ûï New Chat
                </button>
            </div>

            <!-- Example Questions Section -->
            <div class="example-questions-section">
                <div class="example-questions-header" id="example-questions-toggle">
                    <h3>üí° Example Questions</h3>
                    <span class="expand-icon" id="expand-icon">‚ñº</span>
                </div>
                <div class="example-questions-content" id="example-questions-content">
                    <div class="example-question" data-question="What is Boost and how do I get started?">
                        What is Boost and how do I get started?
                    </div>
                    <div class="example-question" data-question="How do I use Boost.Algorithm for string manipulation?">
                        How do I use Boost.Algorithm for string manipulation?
                    </div>
                    <div class="example-question"
                        data-question="What are the best practices for using Boost.Filesystem?">
                        What are the best practices for using Boost.Filesystem?
                    </div>
                    <div class="example-question" data-question="How do I compile and link Boost libraries?">
                        How do I compile and link Boost libraries?
                    </div>
                </div>
            </div>

            <div class="channels-list" id="channels-list">
                <!-- Channels will be populated here -->
            </div>
        </div>

        <!-- Main Chat Container -->
        <div class="chat-container">
            <div class="chat-header">
                <h2 id="current-channel-name">Chat with BoostChatBot</h2>
                <div class="chat-header-controls">
                    <div class="status-indicator">
                        <div class="status-dot"></div>
                        <span id="connection-status">Connected</span>
                    </div>
                    <button id="settings-toggle" class="settings-toggle">
                        ‚öôÔ∏è Settings
                    </button>
                </div>
            </div>

            <div class="chat-messages" id="chat-messages">
                <div class="message bot">
                    <div class="message-avatar">ü§ñ</div>
                    <div class="message-content">
                        <div class="message-text">
                            Hello! I'm BoostChatBot, your AI assistant for C++ Boost library documentation.
                            I can help you with questions about Boost libraries, provide code examples,
                            explain best practices, and guide you through implementation details.
                        </div>
                        <div class="message-meta">
                            <span>BoostChatBot</span>
                            <div class="confidence-bar">
                                <span>Confidence:</span>
                                <div class="confidence-fill">
                                    <div class="confidence-progress" style="width: 100%"></div>
                                </div>
                                <span>100%</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="typing-indicator" id="typing-indicator">
                <div class="message-avatar">ü§ñ</div>
                <div class="typing-dots">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                </div>
                <span id="typing-text">BoostChatBot is thinking...</span>
            </div>
        </div>

        <!-- Settings Panel -->
        <div class="settings-panel hidden" id="settings-panel">
            <div class="settings-panel-content">
                <div class="settings-section">
                    <h3>‚öôÔ∏è RAG Settings</h3>
                    <form class="settings-form" id="settings-form">
                        <div class="form-group">
                            <label for="embedding-model">Embedding Model</label>
                            <select id="embedding-model" name="embedding">
                                <option value="">Loading models...</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Retrieval Method Weights</label>
                            <div class="retrieval-weights">
                                <div class="weight-input">
                                    <label for="vector-search-weight">Vector Search Weight</label>
                                    <input type="number" id="vector-search-weight" name="vector_search_weight" min="0"
                                        max="1" step="0.1" value="0.7" />
                                </div>
                                <div class="weight-input">
                                    <label for="bm25-search-weight">BM25 Search Weight</label>
                                    <input type="number" id="bm25-search-weight" name="bm25_search_weight" min="0"
                                        max="1" step="0.1" value="0.3" />
                                </div>
                                <div class="weight-input">
                                    <label for="graph-search-weight">Graph Search Weight</label>
                                    <input type="number" id="graph-search-weight" name="graph_search_weight" min="0"
                                        max="1" step="0.1" value="0.15" />
                                </div>
                                <div class="weight-input">
                                    <label for="hierarchical-search-weight">Hierarchical Search Weight</label>
                                    <input type="number" id="hierarchical-search-weight"
                                        name="hierarchical_search_weight" min="0" max="1" step="0.1" value="0.15" />
                                </div>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="database-type">Database Type</label>
                            <select id="database-type" name="database">
                                <option value="faiss">FAISS</option>
                                <option value="chroma">Chroma</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="llm-type">LLM Model</label>
                            <select id="llm-type" name="llm">
                                <option value="">Loading models...</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="language-select">Language</label>
                            <select id="language-select" name="language">
                                <option value="en">English</option>
                                <option value="cn">Chinese</option>
                                <option value="fr">French</option>
                                <option value="es">Spanish</option>
                                <option value="de">German</option>
                                <option value="it">Italian</option>
                                <option value="pt">Portuguese</option>
                                <option value="ru">Russian</option>
                                <option value="zh">Chinese (Traditional)</option>
                                <option value="ja">Japanese</option>
                                <option value="ko">Korean</option>
                            </select>
                        </div>
                    </form>
                </div>


                <div class="settings-section">
                    <h3>üìä System Status</h3>
                    <div class="system-status" id="system-status">
                        <div class="status-item">
                            <span class="status-label">Status:</span>
                            <span class="status-value" id="system-status-value">Loading...</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Current Version:</span>
                            <span class="status-value" id="current-version-display">Loading...</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Available Versions:</span>
                            <span class="status-value" id="available-versions-count">Loading...</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">RAG Statistics:</span>
                            <span class="status-value" id="rag-stats">Loading...</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Chat Input Container - Always Visible -->
    <div class="chat-input-container">
        <div class="chat-input-wrapper">
            <!-- Mode Selector -->
            <div class="mode-selector">
                <label class="mode-option">
                    <input type="radio" name="mode" value="query" checked>
                    <span class="mode-label">
                        <span class="mode-icon">üí¨</span>
                        Query
                    </span>
                </label>
                <label class="mode-option">
                    <input type="radio" name="mode" value="search">
                    <span class="mode-label">
                        <span class="mode-icon">üîç</span>
                        Search
                    </span>
                </label>
            </div>

            <textarea id="chat-input" class="chat-input" placeholder="Ask me anything about Boost libraries..."
                rows="1"></textarea>
            <button id="send-button" class="send-button">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="22" y1="2" x2="11" y2="13"></line>
                    <polygon points="22,2 15,22 11,13 2,9"></polygon>
                </svg>
            </button>
        </div>
    </div>

    <script>
        class BoostChatBot {
            constructor() {
                this.apiBase = window.location.origin;
                this.isLoading = false;
                this.currentChannelId = null;
                this.channels = new Map();
                this.channelCounter = 1;

                this.initializeElements();
                this.bindEvents();
                this.loadSystemStatus();
                this.loadRagStatistics();
                this.loadAvailableModels();
                this.createDefaultChannel();

                // Add edit functionality to existing messages after a short delay
                setTimeout(() => {
                    this.addEditFunctionalityToExistingMessages();
                }, 100);
            }

            initializeElements() {
                this.chatMessages = document.getElementById('chat-messages');
                this.chatInput = document.getElementById('chat-input');
                this.sendButton = document.getElementById('send-button');
                this.typingIndicator = document.getElementById('typing-indicator');
                this.connectionStatus = document.getElementById('connection-status');
                this.settingsForm = document.getElementById('settings-form');
                this.settingsToggle = document.getElementById('settings-toggle');
                this.settingsPanel = document.getElementById('settings-panel');
                this.newChatButton = document.getElementById('new-chat-button');
                this.channelsList = document.getElementById('channels-list');
                this.currentChannelName = document.getElementById('current-channel-name');
                this.exampleQuestionsToggle = document.getElementById('example-questions-toggle');
                this.exampleQuestionsContent = document.getElementById('example-questions-content');
                this.expandIcon = document.getElementById('expand-icon');

                // Debug: Check if chat messages container is found
                if (!this.chatMessages) {
                    console.error('Chat messages container not found!');
                } else {
                    console.log('Chat messages container initialized successfully');
                }
            }

            bindEvents() {
                this.sendButton.addEventListener('click', () => this.sendMessage());
                this.chatInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });
                this.chatInput.addEventListener('input', () => this.autoResize());
                this.settingsToggle.addEventListener('click', () => this.toggleSettings());
                this.newChatButton.addEventListener('click', () => this.createNewChannel());

                // Debug example questions toggle
                console.log('Binding example questions toggle:', this.exampleQuestionsToggle);
                const toggleElement = document.getElementById('example-questions-toggle');
                if (toggleElement) {
                    toggleElement.addEventListener('click', () => this.toggleExampleQuestions());
                    console.log('Event listener added successfully');
                } else {
                    console.error('Example questions toggle element not found!');
                }

                this.bindExampleQuestions();
            }

            autoResize() {
                this.chatInput.style.height = 'auto';
                this.chatInput.style.height = Math.min(this.chatInput.scrollHeight, 120) + 'px';
            }

            bindExampleQuestions() {
                const exampleQuestions = document.querySelectorAll('.example-question');
                exampleQuestions.forEach(question => {
                    question.addEventListener('click', () => {
                        const questionText = question.getAttribute('data-question');
                        if (questionText) {
                            // Set the question in the input field
                            this.chatInput.value = questionText;
                            this.autoResize();
                            // Automatically send the message
                            this.sendMessage();
                        }
                    });
                });
            }

            createDefaultChannel() {
                const channelId = 'default';
                const channelName = 'General Chat';
                this.createChannel(channelId, channelName, true);
            }

            createNewChannel() {
                const channelId = `channel_${this.channelCounter++}`;
                const channelName = `Chat ${this.channelCounter - 1}`;
                this.createChannel(channelId, channelName, true);
            }

            createChannel(channelId, channelName, setActive = false) {
                const channel = {
                    id: channelId,
                    name: channelName,
                    messages: [],
                    createdAt: new Date()
                };

                this.channels.set(channelId, channel);
                this.renderChannel(channel);

                if (setActive) {
                    this.switchToChannel(channelId);
                }
            }

            renderChannel(channel) {
                const channelElement = document.createElement('div');
                channelElement.className = 'channel-item';
                channelElement.dataset.channelId = channel.id;

                const lastMessage = channel.messages[channel.messages.length - 1];
                const preview = lastMessage ?
                    (lastMessage.type === 'user' ? `You: ${lastMessage.text}` : `Bot: ${lastMessage.text}`) :
                    'No messages yet';

                channelElement.innerHTML = `
                    <div class="channel-name">${channel.name}</div>
                    <div class="channel-preview">${preview.substring(0, 50)}${preview.length > 50 ? '...' : ''}</div>
                    <div class="channel-actions">
                        <button class="channel-delete" onclick="event.stopPropagation(); chatBot.deleteChannel('${channel.id}')">√ó</button>
                    </div>
                `;

                channelElement.addEventListener('click', () => this.switchToChannel(channel.id));
                this.channelsList.appendChild(channelElement);
            }

            switchToChannel(channelId) {
                // Update active channel
                document.querySelectorAll('.channel-item').forEach(item => {
                    item.classList.remove('active');
                });

                const channelElement = document.querySelector(`[data-channel-id="${channelId}"]`);
                if (channelElement) {
                    channelElement.classList.add('active');
                }

                // Save current channel messages
                if (this.currentChannelId) {
                    this.saveCurrentChannelMessages();
                }

                // Switch to new channel
                this.currentChannelId = channelId;
                const channel = this.channels.get(channelId);

                if (channel) {
                    this.currentChannelName.textContent = channel.name;
                    this.loadChannelMessages(channel);

                    // Add edit functionality to messages after loading
                    setTimeout(() => {
                        this.addEditFunctionalityToExistingMessages();
                    }, 50);
                }
            }

            saveCurrentChannelMessages() {
                if (!this.currentChannelId) return;

                const channel = this.channels.get(this.currentChannelId);
                if (!channel) return;

                // Extract messages from DOM
                const messageElements = this.chatMessages.querySelectorAll('.message');
                channel.messages = [];

                messageElements.forEach(element => {
                    const isUser = element.classList.contains('user');
                    const textElement = element.querySelector('.message-text');
                    if (textElement) {
                        channel.messages.push({
                            type: isUser ? 'user' : 'bot',
                            text: textElement.textContent,
                            timestamp: new Date()
                        });
                    }
                });
            }

            loadChannelMessages(channel) {
                this.chatMessages.innerHTML = '';

                if (channel.messages.length === 0) {
                    // Add welcome message for empty channels
                    const welcomeMessage = this.createMessageElement('bot',
                        'Hello! I\'m BoostChatBot, your AI assistant for C++ Boost library documentation. ' +
                        'I can help you with questions about Boost libraries, provide code examples, ' +
                        'explain best practices, and guide you through implementation details.'
                    );
                    this.chatMessages.appendChild(welcomeMessage);
                } else {
                    // Load existing messages
                    channel.messages.forEach(message => {
                        const messageElement = this.createMessageElement(message.type, message.text);
                        this.chatMessages.appendChild(messageElement);
                    });
                }

                this.scrollToBottom();
            }

            deleteChannel(channelId) {
                if (this.channels.size <= 1) {
                    alert('Cannot delete the last channel');
                    return;
                }

                if (confirm('Are you sure you want to delete this channel?')) {
                    this.channels.delete(channelId);

                    const channelElement = document.querySelector(`[data-channel-id="${channelId}"]`);
                    if (channelElement) {
                        channelElement.remove();
                    }

                    // If we deleted the current channel, switch to the first available channel
                    if (this.currentChannelId === channelId) {
                        const firstChannel = this.channels.keys().next().value;
                        if (firstChannel) {
                            this.switchToChannel(firstChannel);
                        }
                    }
                }
            }

            toggleSettings() {
                this.settingsPanel.classList.toggle('hidden');
            }

            toggleExampleQuestions() {
                console.log('Toggle clicked!');

                // Try to find elements directly if they weren't found during initialization
                const content = document.getElementById('example-questions-content');
                const toggle = document.getElementById('example-questions-toggle');
                const icon = document.getElementById('expand-icon');

                console.log('Content element:', content);
                console.log('Toggle element:', toggle);
                console.log('Icon element:', icon);

                if (!content || !toggle || !icon) {
                    console.error('Elements not found!');
                    return;
                }

                const isCollapsed = content.classList.contains('collapsed');
                console.log('Is collapsed:', isCollapsed);

                if (isCollapsed) {
                    // Expand
                    content.classList.remove('collapsed');
                    toggle.classList.remove('collapsed');
                    icon.textContent = '‚ñº';
                    console.log('Expanding...');
                } else {
                    // Collapse
                    content.classList.add('collapsed');
                    toggle.classList.add('collapsed');
                    icon.textContent = '‚ñ∂';
                    console.log('Collapsing...');
                }
            }

            async sendMessage() {
                const message = this.chatInput.value.trim();
                if (!message || this.isLoading) return;

                console.log('Sending message:', message);
                console.log('Chat messages container:', this.chatMessages);

                // Set loading state
                this.isLoading = true;
                this.sendButton.disabled = true;
                this.sendButton.classList.add('loading');
                this.chatInput.disabled = true;

                // Pre-scroll to ensure we're at the bottom before adding message
                this.forceScrollToBottom();

                this.addUserMessage(message);
                // Don't clear input immediately - let user see what was sent
                setTimeout(() => {
                    this.chatInput.value = '';
                    this.autoResize();
                }, 100);

                try {
                    // Get current RAG settings from the form
                    const ragSettings = this.getCurrentRagSettings();

                    // Get selected mode (query or search)
                    const selectedMode = document.querySelector('input[name="mode"]:checked').value;

                    let response;
                    if (selectedMode === 'search') {
                        // Call search endpoint for retrieval-only results
                        response = await this.callAPI('/search', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                query: message,
                                offset: 0,
                                limit: 5,
                                retrieval_weights: ragSettings.retrieval_weights,
                                embedding: ragSettings.embedding,
                                database: ragSettings.database,
                                language: ragSettings.language
                            })
                        });
                    } else {
                        // Call query endpoint for LLM-generated answers
                        response = await this.callAPI('/query', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                question: message,
                                offset: 0,
                                limit: 5,
                                use_enhanced_rag: false,
                                use_multi_step: false,
                                use_evaluation: false,
                                use_chat_history: true,
                                clear_history: false,
                                retrieval_weights: ragSettings.retrieval_weights,
                                embedding: ragSettings.embedding,
                                database: ragSettings.database,
                                llm: ragSettings.llm,
                                language: ragSettings.language
                            })
                        });
                    }

                    this.hideTypingIndicator();
                    console.log('Received response from API:', response);
                    this.addBotMessage(response);

                    // Update channel preview
                    this.updateChannelPreview();

                } catch (error) {
                    this.hideTypingIndicator();
                    this.addErrorMessage('Sorry, I encountered an error. Please try again.');
                    console.error('Error:', error);
                } finally {
                    // Reset loading state
                    this.isLoading = false;
                    this.sendButton.disabled = false;
                    this.sendButton.classList.remove('loading');
                    this.chatInput.disabled = false;
                    this.chatInput.focus();
                }
            }

            updateChannelPreview() {
                if (!this.currentChannelId) return;

                const channel = this.channels.get(this.currentChannelId);
                if (!channel) return;

                // Find the channel element and update its preview
                const channelElement = document.querySelector(`[data-channel-id="${this.currentChannelId}"]`);
                if (channelElement) {
                    const previewElement = channelElement.querySelector('.channel-preview');
                    if (previewElement) {
                        const lastMessage = channel.messages[channel.messages.length - 1];
                        const preview = lastMessage ?
                            (lastMessage.type === 'user' ? `You: ${lastMessage.text}` : `Bot: ${lastMessage.text}`) :
                            'No messages yet';
                        previewElement.textContent = preview.substring(0, 50) + (preview.length > 50 ? '...' : '');
                    }
                }
            }

            addUserMessage(message) {
                console.log('Adding user message:', message);
                const messageElement = this.createMessageElement('user', message);
                this.chatMessages.appendChild(messageElement);

                // Force immediate scroll
                this.forceScrollToBottom();

                // Add typing indicator right after user message
                this.showTypingIndicator();

                // Additional scroll attempts
                setTimeout(() => this.scrollToBottom(), 10);
                setTimeout(() => this.scrollToBottom(), 100);

                // Save to current channel
                if (this.currentChannelId) {
                    const channel = this.channels.get(this.currentChannelId);
                    if (channel) {
                        channel.messages.push({
                            type: 'user',
                            text: message,
                            timestamp: new Date()
                        });
                    }
                }
                console.log('User message added successfully');
            }

            addEditFunctionalityToExistingMessages() {
                console.log('Adding edit functionality to existing messages...');
                // Add edit functionality to all existing user messages
                const userMessages = this.chatMessages.querySelectorAll('.message.user');
                console.log('Found', userMessages.length, 'user messages');
                userMessages.forEach(messageElement => {
                    const metaElement = messageElement.querySelector('.message-meta');
                    if (metaElement && !metaElement.querySelector('.edit-message-btn')) {
                        // Only add if not already present
                        const textDiv = messageElement.querySelector('.message-text');
                        if (textDiv) {
                            const originalText = textDiv.textContent;

                            // Create user meta with edit button
                            const userMeta = document.createElement('div');
                            userMeta.className = 'user-message-meta';
                            userMeta.innerHTML = `
                                <span>You</span>
                                <div class="message-actions">
                                    <button class="edit-message-btn" title="Edit and resend">‚úèÔ∏è</button>
                                </div>
                            `;

                            // Replace the meta content
                            metaElement.innerHTML = '';
                            metaElement.appendChild(userMeta);

                            // Add click handler for edit button
                            const editBtn = userMeta.querySelector('.edit-message-btn');
                            editBtn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                console.log('Edit button clicked for:', originalText);
                                this.editMessage(textDiv, originalText);
                            });

                            console.log('Edit button added to message:', originalText.substring(0, 50));
                        }
                    }
                });
            }

            addBotMessage(response) {
                console.log('Adding bot message:', response);
                const messageElement = this.createBotMessageElement(response);
                this.chatMessages.appendChild(messageElement);

                // Force immediate scroll
                this.forceScrollToBottom();

                // Additional scroll attempts
                setTimeout(() => this.scrollToBottom(), 10);
                setTimeout(() => this.scrollToBottom(), 100);

                // Save to current channel
                if (this.currentChannelId) {
                    const channel = this.channels.get(this.currentChannelId);
                    if (channel) {
                        channel.messages.push({
                            type: 'bot',
                            text: response.answer,
                            timestamp: new Date()
                        });
                    }
                }
                console.log('Bot message added successfully');
            }

            createMessageElement(type, text) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${type}`;

                const avatar = document.createElement('div');
                avatar.className = 'message-avatar';
                avatar.textContent = type === 'user' ? 'üë§' : 'ü§ñ';

                const content = document.createElement('div');
                content.className = 'message-content';

                const textDiv = document.createElement('div');
                textDiv.className = 'message-text';
                textDiv.textContent = text;

                const meta = document.createElement('div');
                meta.className = 'message-meta';

                if (type === 'user') {
                    // Add edit functionality for user messages
                    const userMeta = document.createElement('div');
                    userMeta.className = 'user-message-meta';
                    userMeta.innerHTML = `
                        <span>You</span>
                        <div class="message-actions">
                            <button class="edit-message-btn" title="Edit and resend">‚úèÔ∏è</button>
                        </div>
                    `;
                    meta.appendChild(userMeta);

                    // Add click handler for edit button
                    const editBtn = userMeta.querySelector('.edit-message-btn');
                    editBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.editMessage(textDiv, text);
                    });
                } else {
                    meta.textContent = 'BoostChatBot';
                }

                content.appendChild(textDiv);
                content.appendChild(meta);
                messageDiv.appendChild(avatar);
                messageDiv.appendChild(content);

                return messageDiv;
            }

            createBotMessageElement(response) {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message bot';

                const avatar = document.createElement('div');
                avatar.className = 'message-avatar';
                avatar.textContent = 'ü§ñ';

                const content = document.createElement('div');
                content.className = 'message-content';

                const textDiv = document.createElement('div');
                textDiv.className = 'message-text';

                // Handle different response formats
                if (response.answer) {
                    // Query response - has LLM-generated answer
                    textDiv.innerHTML = this.formatAnswerText(response.answer);

                    // Also show retrieval results if available
                    if (response.retrieval_results && response.retrieval_results.length > 0) {
                        // Expose last retrieval results to expansion handler
                        window.__lastRetrievalResults = response.retrieval_results;
                        window.__apiBase = this.apiBase;
                        const retrievalSection = document.createElement('div');
                        retrievalSection.className = 'retrieval-results-section';
                        retrievalSection.innerHTML = this.formatRetrievalResults(response.retrieval_results);
                        textDiv.appendChild(retrievalSection);
                    }
                } else if (response.results) {
                    // Search response - render like query retrieval results (no Sources section)
                    window.__lastRetrievalResults = response.results;
                    window.__apiBase = this.apiBase;
                    const retrievalSection = document.createElement('div');
                    retrievalSection.className = 'retrieval-results-section';
                    retrievalSection.innerHTML = this.formatRetrievalResults(response.results);
                    textDiv.appendChild(retrievalSection);
                } else {
                    // Fallback
                    textDiv.innerHTML = '<p>No results found.</p>';
                }

                const meta = document.createElement('div');
                meta.className = 'message-meta';

                // Backend doesn't provide confidence, so we'll show timestamp instead
                const timestamp = new Date(response.timestamp).toLocaleTimeString();
                meta.innerHTML = `
                    <span>BoostChatBot</span>
                    <span>${timestamp}</span>
                `;

                content.appendChild(textDiv);
                content.appendChild(meta);

                // Add sources if available


                // Add version info if available
                if (response.version) {
                    const versionInfo = document.createElement('div');
                    versionInfo.className = 'version-info';
                    versionInfo.style.cssText = 'font-size: 0.8rem; color: #6b7280; margin-top: 0.5rem;';
                    versionInfo.textContent = `Version: ${response.version}`;
                    content.appendChild(versionInfo);
                }

                messageDiv.appendChild(avatar);
                messageDiv.appendChild(content);

                return messageDiv;
            }

            formatAnswerText(text) {
                if (!text) return '';

                // Convert line breaks to HTML
                let formattedText = text
                    .replace(/\n\n/g, '</p><p>')
                    .replace(/\n/g, '<br>');

                // Wrap in paragraph tags if not already wrapped
                if (!formattedText.startsWith('<p>')) {
                    formattedText = '<p>' + formattedText + '</p>';
                }

                // Format code blocks
                formattedText = formattedText.replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code class="language-$1">$2</code></pre>');

                // Format inline code
                formattedText = formattedText.replace(/`([^`]+)`/g, '<code>$1</code>');

                // Format bullet points
                formattedText = formattedText.replace(/^[\s]*[-*+]\s+(.+)$/gm, '<li>$1</li>');
                formattedText = formattedText.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');

                // Format numbered lists
                formattedText = formattedText.replace(/^[\s]*\d+\.\s+(.+)$/gm, '<li>$1</li>');

                // Format headers (## Header -> <h3>Header</h3>)
                formattedText = formattedText.replace(/^##\s+(.+)$/gm, '<h3>$1</h3>');
                formattedText = formattedText.replace(/^###\s+(.+)$/gm, '<h4>$1</h4>');

                // Format bold text
                formattedText = formattedText.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');

                // Format italic text
                formattedText = formattedText.replace(/\*(.+?)\*/g, '<em>$1</em>');

                return formattedText;
            }

            formatSearchResults(response) {
                if (!response.results || response.results.length === 0) {
                    return '<p>No search results found.</p>';
                }

                let html = '<div class="search-results">';
                html += `<h3>üîç Search Results (${response.total_results} found)</h3>`;

                response.results.forEach((result, index) => {
                    const truncatedText = result.text.length > 300 ? result.text.substring(0, 300) + '...' : result.text;
                    const isLongText = result.text.length > 300;

                    html += `
                        <div class="search-result-item">
                            <div class="search-result-header">
                                <span class="result-number">${index + 1}</span>
                                <span class="result-method">${result.retrieval_method || 'unknown'}</span>
                                <span class="result-score">Score: ${result.score ? result.score.toFixed(3) : 'N/A'}</span>
                            </div>
                            <div class="search-result-file">üìÑ ${result.source_file || 'Unknown file'}</div>
                            <div class="search-result-content">
                                <div class="search-result-text">${truncatedText}</div>
                                ${isLongText ? `
                                    <button class="expand-search-btn" onclick="toggleSearchText(${index})">
                                        <span class="expand-text">Show more</span>
                                        <span class="expand-icon">‚ñº</span>
                                    </button>
                                    <div class="search-result-full" style="display: none;">${result.text}</div>
                                ` : ''}
                            </div>
                        </div>
                    `;
                });

                html += '</div>';
                return html;
            }

            formatRetrievalResults(retrievalResults) {
                if (!retrievalResults || retrievalResults.length === 0) {
                    return '<p>No retrieval results available.</p>';
                }

                let html = '<div class="retrieval-results">';
                html += `<h4>üìö Results (${retrievalResults.length} found)</h4>`;

                retrievalResults.forEach((result, index) => {
                    const fileLine = `${result.source_file || 'Unknown source'}`;
                    const previewLine = result.text || '';
                    const isLongText = (result.text || '').length > 200;
                    const truncatedText = isLongText ? previewLine.substring(0, 200) + '...' : previewLine;
                    const sourceType = (result.source_type || '').toLowerCase();
                    const metadata = result.metadata || {};

                    html += `
                        <div class="retrieval-result-item">
                            <div class="retrieval-result-header">
                                <span class="result-number">${index + 1}</span>
                                <span class="result-method">${result.retrieval_method || 'unknown'}</span>
                                <span class="result-score">Score: ${result.score ? result.score.toFixed(3) : 'N/A'}</span>
                            </div>
                            <div class="retrieval-result-file"><a href="${fileLine}" target="_blank">üìÑ ${fileLine}</a></div>
                            <div class="retrieval-result-content">
                                <div class="retrieval-result-text">${truncatedText}</div>
                                <button class="expand-retrieval-btn" onclick="expandRetrieval(${index})">
                                    <span class="expand-text">Show more</span>
                                    <span class="expand-icon">‚ñº</span>
                                </button>
                                <div class="retrieval-result-full" id="retrieval-full-${index}" data-loaded="false" style="display: none;">
                                    <!-- full content will be loaded on demand -->
                                </div>
                            </div>
                        </div>
                    `;
                });

                html += '</div>';
                return html;
            }

            addErrorMessage(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.textContent = message;
                this.chatMessages.appendChild(errorDiv);
                this.scrollToBottom();
            }

            showTypingIndicator() {
                // Create a new typing indicator for this specific message
                const typingElement = document.createElement('div');
                typingElement.className = 'typing-indicator';
                typingElement.id = 'typing-indicator-current';
                typingElement.innerHTML = `
                    <div class="message-avatar">ü§ñ</div>
                    <div class="typing-dots">
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                    <span class="typing-text">BoostChatBot is thinking...</span>
                `;

                // Insert right after the last user message
                const lastUserMessage = this.chatMessages.querySelector('.message.user:last-child');
                if (lastUserMessage) {
                    lastUserMessage.insertAdjacentElement('afterend', typingElement);
                } else {
                    // Fallback: append to end if no user message found
                    this.chatMessages.appendChild(typingElement);
                }

                // Force immediate scroll
                this.forceScrollToBottom();

                // Additional scroll attempts
                setTimeout(() => this.scrollToBottom(), 10);
                setTimeout(() => this.scrollToBottom(), 100);

                // Add dynamic typing text
                const typingText = typingElement.querySelector('.typing-text');
                const messages = [
                    'BoostChatBot is thinking...',
                    'Analyzing your question...',
                    'Searching for information...',
                    'Processing results...',
                    'Generating response...'
                ];

                let messageIndex = 0;
                this.typingInterval = setInterval(() => {
                    if (typingText) {
                        typingText.textContent = messages[messageIndex];
                        messageIndex = (messageIndex + 1) % messages.length;
                    }
                }, 2000);
            }

            hideTypingIndicator() {
                // Remove the current typing indicator
                const currentTypingIndicator = document.getElementById('typing-indicator-current');
                if (currentTypingIndicator) {
                    currentTypingIndicator.remove();
                }

                // Also hide the original typing indicator (fallback)
                if (this.typingIndicator) {
                    this.typingIndicator.style.display = 'none';
                }

                if (this.typingInterval) {
                    clearInterval(this.typingInterval);
                    this.typingInterval = null;
                }
            }

            editMessage(textDiv, originalText) {
                console.log('editMessage called with:', originalText);

                // Create edit interface
                const editContainer = document.createElement('div');
                editContainer.className = 'edit-message-container';

                const editInput = document.createElement('textarea');
                editInput.className = 'edit-message-input';
                editInput.value = originalText;
                editInput.rows = Math.max(2, originalText.split('\n').length);

                const editActions = document.createElement('div');
                editActions.className = 'edit-message-actions';
                editActions.innerHTML = `
                    <button class="save-edit-btn">‚úÖ Save & Send</button>
                    <button class="cancel-edit-btn">‚ùå Cancel</button>
                `;

                editContainer.appendChild(editInput);
                editContainer.appendChild(editActions);

                // Replace the text div with edit interface
                textDiv.parentNode.replaceChild(editContainer, textDiv);

                // Focus and select the text
                editInput.focus();
                editInput.select();

                // Auto-resize textarea
                editInput.addEventListener('input', () => {
                    editInput.style.height = 'auto';
                    editInput.style.height = Math.min(editInput.scrollHeight, 120) + 'px';
                });

                // Handle save
                editActions.querySelector('.save-edit-btn').addEventListener('click', () => {
                    const newText = editInput.value.trim();
                    if (newText && newText !== originalText) {
                        // Update the message text
                        textDiv.textContent = newText;
                        textDiv.parentNode.replaceChild(textDiv, editContainer);

                        // Send the edited message
                        this.chatInput.value = newText;
                        this.autoResize();
                        this.sendMessage();
                    } else {
                        // Just restore original text
                        textDiv.parentNode.replaceChild(textDiv, editContainer);
                    }
                });

                // Handle cancel
                editActions.querySelector('.cancel-edit-btn').addEventListener('click', () => {
                    textDiv.parentNode.replaceChild(textDiv, editContainer);
                });

                // Handle Enter key to save, Escape to cancel
                editInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        editActions.querySelector('.save-edit-btn').click();
                    } else if (e.key === 'Escape') {
                        editActions.querySelector('.cancel-edit-btn').click();
                    }
                });
            }

            forceScrollToBottom() {
                // Immediate, aggressive scroll
                if (this.chatMessages) {
                    this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
                    console.log('Force scroll: ScrollTop:', this.chatMessages.scrollTop, 'ScrollHeight:', this.chatMessages.scrollHeight);
                }
            }

            scrollToBottom() {
                // Multiple attempts to ensure scrolling works
                const scrollAttempts = [0, 10, 50, 100]; // Try immediately, then with delays

                scrollAttempts.forEach(delay => {
                    setTimeout(() => {
                        if (this.chatMessages) {
                            const oldScrollTop = this.chatMessages.scrollTop;
                            this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
                            console.log(`Scroll attempt ${delay}ms: ScrollTop: ${oldScrollTop} -> ${this.chatMessages.scrollTop}, ScrollHeight: ${this.chatMessages.scrollHeight}`);
                        }
                    }, delay);
                });
            }

            async loadSystemStatus() {
                try {
                    const response = await this.callAPI('/status');

                    document.getElementById('system-status-value').textContent = 'Healthy';
                    document.getElementById('current-version-display').textContent = response.current_version || 'None';
                    document.getElementById('available-versions-count').textContent = response.available_versions ? response.available_versions.length : '0';

                    // Update RAG stats if available
                    if (response.rag_statistics) {
                        const stats = response.rag_statistics;
                        document.getElementById('rag-stats').textContent =
                            `Embeddings: ${stats.total_embeddings || 0}, Entities: ${stats.knowledge_graph_entities || 0}`;
                    } else {
                        document.getElementById('rag-stats').textContent = 'Not loaded';
                    }

                    this.connectionStatus.textContent = 'Connected';
                    this.connectionStatus.style.color = '#4ade80';

                } catch (error) {
                    document.getElementById('system-status-value').textContent = 'Error';
                    this.connectionStatus.textContent = 'Disconnected';
                    this.connectionStatus.style.color = '#ef4444';
                    console.error('Error loading system status:', error);
                }
            }


            async loadRagStatistics() {
                try {
                    const response = await this.callAPI('/rag/stats');
                    if (response.message) {
                        document.getElementById('rag-stats').textContent = response.message;
                    } else {
                        document.getElementById('rag-stats').textContent = 'RAG system loaded';
                    }
                } catch (error) {
                    console.error('Error loading RAG statistics:', error);
                    document.getElementById('rag-stats').textContent = 'Error loading stats';
                }
            }

            async loadAvailableModels() {
                try {
                    console.log('Loading available models...');

                    // Load RAG configuration for dropdowns
                    const ragConfig = await this.callAPI('/config/rag');
                    console.log('‚úÖ Loaded RAG configuration:', ragConfig);

                    // Populate retrieval weights from config
                    const vectorWeight = document.getElementById('vector-search-weight');
                    const bm25Weight = document.getElementById('bm25-search-weight');
                    const graphWeight = document.getElementById('graph-search-weight');
                    const hierarchicalWeight = document.getElementById('hierarchical-search-weight');

                    if (ragConfig.retrieval_default_weight) {
                        if (vectorWeight) vectorWeight.value = ragConfig.retrieval_default_weight['vector search'] || 0.5;
                        if (bm25Weight) bm25Weight.value = ragConfig.retrieval_default_weight['bm25 search'] || 0.2;
                        if (graphWeight) graphWeight.value = ragConfig.retrieval_default_weight['graph search'] || 0.15;
                        if (hierarchicalWeight) hierarchicalWeight.value = ragConfig.retrieval_default_weight['hierarchical search'] || 0.15;
                        console.log('‚úÖ Loaded retrieval weights:', ragConfig.retrieval_default_weight);
                    }

                    // Semantic chunking is always used (no UI needed)

                    // Populate database types from config
                    const databaseSelect = document.getElementById('database-type');
                    if (databaseSelect && ragConfig.database_types) {
                        databaseSelect.innerHTML = '';
                        ragConfig.database_types.forEach(type => {
                            const option = document.createElement('option');
                            option.value = type;
                            option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
                            if (type === ragConfig.defaults.database) {
                                option.selected = true;
                            }
                            databaseSelect.appendChild(option);
                        });
                        console.log('‚úÖ Loaded database types:', ragConfig.database_types);
                    }

                    // Set default language from config
                    const languageSelect = document.getElementById('language-select');
                    if (languageSelect && ragConfig.defaults.language) {
                        languageSelect.value = ragConfig.defaults.language;
                        console.log('‚úÖ Set default language:', ragConfig.defaults.language);
                    }

                } catch (error) {
                    console.error('‚ùå Error loading RAG configuration:', error);
                }

                // Load LLM models from Ollama (separate from config)
                try {
                    const llmResponse = await this.callAPI('/models/llm');
                    const llmSelect = document.getElementById('llm-type');
                    if (llmSelect) {
                        llmSelect.innerHTML = '';
                        if (llmResponse && llmResponse.models && llmResponse.models.length > 0) {
                            llmResponse.models.forEach(model => {
                                const option = document.createElement('option');
                                option.value = model.name;
                                // Show model name with size info for better UX
                                const sizeInfo = model.size > 0 ? ` (${(model.size / 1024 / 1024 / 1024).toFixed(1)}GB)` : '';
                                option.textContent = `${model.name}${sizeInfo}`;
                                llmSelect.appendChild(option);
                            });
                            console.log('‚úÖ Loaded LLM models from Ollama:', llmResponse.models);
                        } else {
                            llmSelect.innerHTML = '<option value="">No LLM models available</option>';
                        }
                    }
                } catch (error) {
                    console.error('‚ùå Error loading LLM models:', error);
                    // Set fallback LLM options
                    const llmSelect = document.getElementById('llm-type');
                    if (llmSelect) {
                        llmSelect.innerHTML = `
                            <option value="gemma3:12b">gemma3:12b (fallback)</option>
                            <option value="llama2">llama2 (fallback)</option>
                            <option value="mistral">mistral (fallback)</option>
                        `;
                    }
                }

                // Load embedding models from Ollama (separate from config)
                try {
                    const embeddingResponse = await this.callAPI('/models/embedding');
                    const embeddingSelect = document.getElementById('embedding-model');
                    if (embeddingSelect) {
                        embeddingSelect.innerHTML = '';
                        // Extract models array from response object
                        const models = embeddingResponse.models || embeddingResponse;
                        if (models && models.length > 0) {
                            models.forEach(model => {
                                const option = document.createElement('option');
                                option.value = model;
                                option.textContent = model;
                                embeddingSelect.appendChild(option);
                            });
                            console.log('‚úÖ Loaded embedding models from Ollama:', models);
                        } else {
                            embeddingSelect.innerHTML = '<option value="">No embedding models available</option>';
                        }
                    }
                } catch (error) {
                    console.error('‚ùå Error loading embedding models:', error);
                    // Set fallback embedding options
                    const embeddingSelect = document.getElementById('embedding-model');
                    if (embeddingSelect) {
                        embeddingSelect.innerHTML = `
                            <option value="sentence-transformers/all-MiniLM-L6-v2">sentence-transformers/all-MiniLM-L6-v2 (fallback)</option>
                            <option value="google/embeddinggemma-300m">google/embeddinggemma-300m (fallback)</option>
                        `;
                    }
                }
            }

            setDefaultModelOptions() {
                console.log('Setting fallback model options...');

                // Set default retrieval weights if API fails
                const vectorWeight = document.getElementById('vector-search-weight');
                const bm25Weight = document.getElementById('bm25-search-weight');
                const graphWeight = document.getElementById('graph-search-weight');
                const hierarchicalWeight = document.getElementById('hierarchical-search-weight');

                if (vectorWeight) vectorWeight.value = 0.5;
                if (bm25Weight) bm25Weight.value = 0.2;
                if (graphWeight) graphWeight.value = 0.15;
                if (hierarchicalWeight) hierarchicalWeight.value = 0.15;

                // Set default database types if API fails
                const databaseSelect = document.getElementById('database-type');
                if (databaseSelect) {
                    databaseSelect.innerHTML = `
                        <option value="faiss" selected>Faiss (fallback)</option>
                        <option value="chroma">Chroma (fallback)</option>
                    `;
                }
            }

            getCurrentRagSettings() {
                // Get current values from the form
                const vectorWeight = document.getElementById('vector-search-weight');
                const bm25Weight = document.getElementById('bm25-search-weight');
                const graphWeight = document.getElementById('graph-search-weight');
                const hierarchicalWeight = document.getElementById('hierarchical-search-weight');
                const embeddingSelect = document.getElementById('embedding-model');
                const databaseSelect = document.getElementById('database-type');
                const llmSelect = document.getElementById('llm-type');
                const languageSelect = document.getElementById('language-select');

                return {
                    embedding: embeddingSelect ? embeddingSelect.value : '',
                    database: databaseSelect ? databaseSelect.value : 'faiss',
                    retrieval_weights: {
                        'vector search': vectorWeight ? parseFloat(vectorWeight.value) || 0.5 : 0.5,
                        'bm25 search': bm25Weight ? parseFloat(bm25Weight.value) || 0.2 : 0.2,
                        'graph search': graphWeight ? parseFloat(graphWeight.value) || 0.15 : 0.15,
                        'hierarchical search': hierarchicalWeight ? parseFloat(hierarchicalWeight.value) || 0.15 : 0.15
                    },
                    llm: llmSelect ? llmSelect.value : '',
                    language: languageSelect ? languageSelect.value : 'en'
                };
            }


            showSuccessMessage(message) {
                const successDiv = document.createElement('div');
                successDiv.className = 'success-message';
                successDiv.textContent = message;
                this.chatMessages.appendChild(successDiv);
                this.scrollToBottom();

                setTimeout(() => {
                    successDiv.remove();
                }, 3000);
            }

            showErrorMessage(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.textContent = message;
                this.chatMessages.appendChild(errorDiv);
                this.scrollToBottom();

                setTimeout(() => {
                    errorDiv.remove();
                }, 5000);
            }

            async callAPI(endpoint, options = {}) {
                const response = await fetch(this.apiBase + endpoint, options);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                return await response.json();
            }
        }

        // Initialize the chat bot when the page loads
        let chatBot;
        document.addEventListener('DOMContentLoaded', () => {
            chatBot = new BoostChatBot();
        });

        // Function to toggle source text expansion
        function toggleSourceText(index) {
            const button = event.target.closest('.expand-btn');
            const fullText = button.parentElement.querySelector('.source-text-full');
            const expandText = button.querySelector('.expand-text');
            const expandIcon = button.querySelector('.expand-icon');

            if (fullText.style.display === 'none') {
                fullText.style.display = 'block';
                expandText.textContent = 'Show less';
                expandIcon.textContent = '‚ñ≤';
                button.classList.add('expanded');
            } else {
                fullText.style.display = 'none';
                expandText.textContent = 'Show more';
                expandIcon.textContent = '‚ñº';
                button.classList.remove('expanded');
            }
        }

        // Toggle function for search result text expansion
        function toggleSearchText(index) {
            const button = document.querySelector(`.expand-search-btn:nth-of-type(${index + 1})`);
            const fullText = button.parentNode.querySelector('.search-result-full');
            const expandText = button.querySelector('.expand-text');
            const expandIcon = button.querySelector('.expand-icon');

            if (fullText.style.display === 'none' || fullText.style.display === '') {
                fullText.style.display = 'block';
                expandText.textContent = 'Show less';
                expandIcon.textContent = '‚ñ≤';
                button.classList.add('expanded');
            } else {
                fullText.style.display = 'none';
                expandText.textContent = 'Show more';
                expandIcon.textContent = '‚ñº';
                button.classList.remove('expanded');
            }
        }

        async function expandRetrieval(index) {
            const button = event.target.closest('.expand-retrieval-btn');
            const container = button.parentNode;
            const fullBox = container.querySelector(`#retrieval-full-${index}`);
            const expandText = button.querySelector('.expand-text');
            const expandIcon = button.querySelector('.expand-icon');
            if (!fullBox) return;
            if (fullBox.style.display === 'none' || fullBox.style.display === '') {
                // Load on demand if not loaded yet
                if (fullBox.getAttribute('data-loaded') !== 'true') {
                    try {
                        // Locate the corresponding result data from the last bot message
                        const lastBot = document.querySelector('.message.bot .message-text .retrieval-results');
                        // Fallback: scan all retrieval sections
                        const sections = document.querySelectorAll('.retrieval-results');
                        let resultData = null;
                        // Find index-th retrieval result in the latest block by reading dataset from a shadow copy we placed on window
                        if (window.__lastRetrievalResults && window.__lastRetrievalResults[index]) {
                            resultData = window.__lastRetrievalResults[index];
                        }
                        if (!resultData) {
                            fullBox.innerText = 'Unable to load details.';
                            fullBox.setAttribute('data-loaded', 'true');
                        } else {
                            // Decide which API to call based on type
                            const sourceType = (resultData.source_type || '').toLowerCase();
                            if (sourceType === 'email') {
                                // Minimal email details only (no full content)
                                const md = resultData.metadata || {};
                                const sender = md.sender_address || md.from || '';
                                const date = md.date || '';
                                const to = md.to || '';
                                const subject = md.subject || '';
                                const url = md.url || resultData.source_file || '';
                                if (sender || date || to || subject || url) {
                                    const urlHtml = url ? `<div>URL: <a href="${url}" target="_blank">${url}</a></div>` : '';
                                    fullBox.innerHTML = `
                                        <div><strong>From:</strong> ${sender}</div>
                                        <div><strong>To:</strong> ${to}</div>
                                        <div><strong>Date:</strong> ${date}</div>
                                        <div><strong>Subject:</strong> ${subject}</div>
                                        ${urlHtml}
                                    `;
                                } else {
                                    const params = new URLSearchParams();
                                    if (resultData.source_file) params.set('url', resultData.source_file);
                                    const res = await fetch(`${(window.__apiBase || '')}/mail/message?${params.toString()}`);
                                    const data = await res.json();
                                    const urlHtml = data.url ? `<div>URL: <a href="${data.url}" target="_blank">${data.url}</a></div>` : '';
                                    fullBox.innerHTML = `
                                        <div><strong>From:</strong> ${data.sender_address || ''}</div>
                                        <div><strong>To:</strong> ${data.to || ''}</div>
                                        <div><strong>Date:</strong> ${data.date || ''}</div>
                                        <div><strong>Subject:</strong> ${data.subject || ''}</div>
                                        ${urlHtml}
                                    `;
                                }
                            } else {
                                // Document: fetch full text based on relative source_file path
                                const lang = (resultData.metadata && resultData.metadata.language) || undefined;
                                const params = new URLSearchParams();
                                if (resultData.source_file) params.set('path', resultData.source_file);
                                if (lang) params.set('language', lang);
                                const res = await fetch(`${(window.__apiBase || '')}/doc/fulltext?${params.toString()}`);
                                const data = await res.json();
                                fullBox.innerHTML = `<pre style="white-space: pre-wrap;">${data.content || ''}</pre>`;
                            }
                            fullBox.setAttribute('data-loaded', 'true');
                        }
                    } catch (e) {
                        fullBox.innerText = 'Failed to load content.';
                        fullBox.setAttribute('data-loaded', 'true');
                    }
                }
                fullBox.style.display = 'block';
                expandText.textContent = 'Show less';
                expandIcon.textContent = '‚ñ≤';
                button.classList.add('expanded');
            } else {
                fullBox.style.display = 'none';
                expandText.textContent = 'Show more';
                expandIcon.textContent = '‚ñº';
                button.classList.remove('expanded');
            }
        }
    </script>
</body>

</html>